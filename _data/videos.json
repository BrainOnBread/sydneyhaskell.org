{
  "talks": [
    {
      "title": "Partial Derivatives of Regular Expressions",
      "abstract": "Brian Hurt explains a different approach, with a number of advantages, to implementing regular expressions. Despite the title, no math is actually required- so if you don't remember calculus (or never took it), that's OK.  A pragmatic understanding of regular expressions is assumed however.  This is a Haskell-based variation of a previous talk on this topic, so there will be some discussion on the differences between Haskell and Clojure.",
      "talk_date": "2016-03-23 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/229615869/",
      "youtubeId": "QVdBPvOOjBA",
      "slides_url": "https://github.com/bhurt/presentations/blob/master/pdrehs.odp?raw=true",
      "speaker": {
        "name": "Brian Hurt",
        "github": "https://github.com/bhurt",
        "twitter": "https://twitter.com/bhurt42"
      },
      "modal": "partial-derivatives-of-regular-expressions"
    },
    {
      "title": "Translating Hardware to Haskell",
      "abstract": "Despite years of research, most digital integrated circuits are still described in low-level register-transfer languages like Verilog and VHDL.  Users must enumerate nearly every gate, wire, and flip-flop, something we would like to avoid in today's era of billion-transistor chips.  Moreover, types in these languages tend to be limited to bit vectors, and even basic control constructs such as iteration are barely supported.<br/><br/>
      Consequently, many have proposed higher-level hardware description languages, allowing the designer to specify behavior of their computation without concern for such low-level implementation details. These efforts have demonstrated the importance of the original language semantics.  Imperative languages such as C tend to produce mediocre hardware because their semantics rest on a single, global memory that is difficult to parallelize.  Functional languages in the form of embedded DSLs have met with more success.<br/><br/>
      Rather than have the developer express his or her computation in a hardware-oriented DSL, we propose that they describe their circuit using a standard, modern functional language such as Haskell. This talk presents a language, FHW, that is serves as an intermediate representation for a general Haskell-to-hardware compiler.<br/><br/>
      The goal of the work presented here is to synthesize hardware from arbitrary Haskell programs through a series of semantics-preserving transformations that ultimately fit a program to FHW--a dialect of GHC's Core intermediate representation that admits a syntax-directed translation to hardware.",
      "talk_date": "2016-02-24 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/228747255/",
      "youtubeId": "k02mEtPfdaQ",
      "slides_url": "",
      "speaker": {
        "name": "Lianne Lairmore",
        "github": "",
        "twitter": ""
      },
      "modal": "hw16"
    },
    {
      "title": "Interactive Theorem Proving with Lean",
      "abstract": "The last decade has seen interactive theorem proving go from the ivory tower of theory to impressive applications, notably the Compcert certified C compiler [1][1] and the mechanized proof of the Feit-Thompson theorem whose proof is a daunting 200 pages of graduate mathematics [2][2]. It's tempting to hope that interactive theorem proving could become a mundane part of programming practice in industry, where designs are validated by computer-assisted proof rather than tests or manual review. <br/><br/>
      This talk will present a new ITP system called Lean [3][3], which is based on dependent type theory. It will also give an overview of the basics of interactive theorem proving, outlining the system design (contrasting it to programming language design) and showing concrete examples. First we will give an overview of the general approach and present some basic examples to help give a feel for the everyday practice of proving theorems. The second part of the talk will then contrast Lean with other ITP systems (such as Coq and Agda) and give some taste of the more advanced features of the system.<br/>
      [1]: http://compcert.inria.fr/
      [2]: http://research.microsoft.com/en-us/news/features/gonthierproof-101112.aspx
      [3]: https://leanprover.github.io/about/ ",
      "bio": "Cody Roux has a PhD in Type Theory from INRIA, and worked on elements of the Lean theorem prover while a Postdoc at CMU, particularly the elaborator. He is a co-author with Leonardo de Moura, Jeremy Avigad, and Soonho Kon of the paper \"Elaboration in Dependent Type Theory\" (http://arxiv.org/abs/1505.04324) which describes the elaboration algorithm used in Lean. He currently works for Draper Labs at Cambridge, MA.",
      "talk_date": "2015-11-25 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/226667224/",
      "youtubeId": "tU5HfVc2nR8",
      "slides_url": "https://github.com/codyroux/ny-haskell/blob/master/slides/talk.pdf",
      "speaker": {
        "name": "Cody Roux",
        "github": "",
        "twitter": ""
      },
      "modal": "theorem15"
    },
    {
      "title": "Struture Editing Combinators",
      "abstract": "Jason Priestley will talk about Structure Editing Combinators. A Structure Editor is an editor that operates directly on the abstract tree structure of a program, instead of textual code. Structure Editing Combinators are Parsec-style combinators, which resemble a high-level specification of the grammar of a language; instead of producing a parser for that langauge, they produce a Structure Editor, with pretty-printing, mouse-based selection, and autocompleting text input.",
      "bio": "Jason Priestley has been programming since 2007, writing web UIs for companies like Fitbit and Birst. He has been writing Haskell since 2009, and is the author of the new Sneath Lane web UI library, as well as the defunct Haskell on a Horse web framework.",
      "talk_date": "2015-10-28 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/225618891/",
      "youtubeId": "u9f5rbjACZU",
      "slides_url": "",
      "speaker": [
        "name": "Jason Priestley",
        "github": "",
        "twitter": ""
      ],
      "modal": "structureediting"
    },
    {
      "title": "The Not-A-Wat in Haskell",
      "abstract": "",
      "talk_date": "",
      "meetup_url": "",
      "youtubeId": "87re_yIQMDw",
      "slides_url": "",
      "speaker": {
        "name": "Brian Hurt",
        "github": "",
        "twitter": ""
      },
      "modal": "notawat"
    },
    {
      "title": "Parallel Computation of Cryptographic Hash Functions",
      "abstract": "This talk is an exploration of some work in progress that resulted  from an attempt to answer these questions: 1) How to arrive at a multicore reference implementation of the Sakura tree hash mode? 2) How to enable communication of \"shape\" between the entity that computes a cryptographic tree hash with the verifier of this hash? 3) How well does this reference implementation scale w.r.t. the number of cores, sizes of inputs, and variety of shapes?  4) How to do all this without becoming an expert on C++ parallel programming?<br/><br/>

        This talk will be introductory and self-contained.  All we require of  the audience is willingness and ability to read Haskell code.<br/><br/>

        Extended Technical Notes:<br/><br/>

        Wikipedia defines a cryptographic hash function as a hash function which is effectively impossible to invert, that is, to recreate the input data from its hash value alone. These functions have been called \"the workhorses of modern cryptography\" and have many information security applications, notably in digital signatures, message authentication codes (MACs), and other forms of authentication of messages. <br/><br/>

        The ideal cryptographic hash function has four main properties: 1) it is easy to compute the hash value for any given input, 2) it is infeasible to generate a input from its hash value, 3) it is infeasible to modify a input without changing its hash value, and 4) it is infeasible to find two different inputs with the same hash value. <br/><br/>

        The NIST announced a public competition in November 2007 to develop a new cryptographic hash algorithm, called SHA-3, for standardization. NIST announced Keccak as the winner of the SHA-3 Cryptographic Hash Algorithm Competition on October 2, 2012, and ended the five-year competition. The authors of Keccak also proposed a flexible, fairly general, encoding for tree hash modes, in order to enable the possibility to cleanly carry out sub-computations in parallel. Their \"Sakura\" encoding specifies how to use a standard cryptographic hash function on suitably divided portions of a long input message and combine the outputs so obtained in order to arrive at a single hash value enjoying the four properties listed above. The authors did not specify the mode by which the computer of the hash value communicates the \"shape\" in which these sub-computations are organized to verifiers of the hash. We designed a Domain Specific Language in Haskell in order to do this in a compact, understandable manner.",
      "talk_date": "2015-09-23 20:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/225238417/",
      "youtubeId": "VL04HTzL2B0",
      "slides_url": "http://files.meetup.com/5087172/MultiCoreHaskellSak.pdf",
      "speaker": {
        "name": "Prasad Rao",
        "github": "",
        "twitter": ""
      },
      "modal": "parallel"
    },
    {
      "title": "Wrangling Monad Transformer Stacks",
      "abstract": "The first of what a projected series of talks on libraries (and other language aspects) which are very useful, but don't get the publicity they deserve.  This talk focuses on libraries to manage monad transformer stacks.  Monad transformer stacks show up quite a lot in real world Haskell programs, and this talk will introduce several libraries that make working with them easier.",
      "talk_date": "2015-08-26 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/224402807/",
      "youtubeId": "8t8fjkISjus",
      "slides_url": "https://github.com/bhurt/presentations/blob/master/hsgems.odp",
      "speaker": {
        "name": "Brian Hurt",
        "github": "",
        "twitter": ""
      },
      "modal": "wrangle"
    },
    {
      "title": "Set Theory and Haskell Part 1",
      "abstract": "What is Set Theory: </b><br/><br/>
      ZFC set theory is an axiomatic theory of sets. The reason for such a theory is that one wants a \"definition\" of what a set is. The reason that sets are important to mathematics is that they provide an encoding of most of mathematics (there are a couple of reasons why one cannot encode all of math).
      <br/><br/>
      <b>Why Learn about Set Theory:</b><br/><br/>

      Axiomatic set theories provide the theoretical underpinnings of various subjects of interest to programmers and computer scientists. For instance relational database theory, and Lisp/scheme are both based upon set theory. ZFC set theory in particular acts as an assembly language for most of mathematics. It is also interesting to note the quite a few of the axioms of ZFC come naturally out of common functional constructs such as Append, Filter, and Map. 
      <br/><br/>
      <b>What I will be Discussing:</b><br/><br/>

      In this talk, I will discuss the theory of ZFC set theory, its raison d'etre (to be pretentious), as well as some applications (time permitting). Some Haskell code will also be shown that illustrates the axioms of ZFC.",
      "talk_date": "2015-06-24 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/222965983/",
      "youtubeId": "beaBqjLhBJU",
      "slides_url": "",
      "speaker": {
        "name": "Lou Thrall",
        "github": "",
        "twitter": ""
      },
      "modal": "setTheory2015"
    }, 
    {
      "title": "Set Theory and Haskell Part 2",
      "abstract": "What is Set Theory: </b><br/><br/>
      ZFC set theory is an axiomatic theory of sets. The reason for such a theory is that one wants a \"definition\" of what a set is. The reason that sets are important to mathematics is that they provide an encoding of most of mathematics (there are a couple of reasons why one cannot encode all of math).
      <br/><br/>
      <b>Why Learn about Set Theory:</b><br/><br/>

      Axiomatic set theories provide the theoretical underpinnings of various subjects of interest to programmers and computer scientists. For instance relational database theory, and Lisp/scheme are both based upon set theory. ZFC set theory in particular acts as an assembly language for most of mathematics. It is also interesting to note the quite a few of the axioms of ZFC come naturally out of common functional constructs such as Append, Filter, and Map. 
      <br/><br/>
      <b>What I will be Discussing:</b><br/><br/>

      In this talk, I will discuss the theory of ZFC set theory, its raison d'etre (to be pretentious), as well as some applications (time permitting). Some Haskell code will also be shown that illustrates the axioms of ZFC.",
      "talk_date": "2015-06-24 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/222965983/",
      "youtubeId": "jhIviVZ5ORE",
      "slides_url": "",
      "speaker": {
        "name": "Lou Thrall",
        "github": "",
        "twitter": ""
      },
      "modal": "setTheory2015"
    }, 
    {
      "title": "Diagrams: Composition, Envelopes, and Alignment Part 1",
      "abstract": "The diagrams library, which makes drawing complex pictures easy in with Haskell code, has just released a slew of new features with version 1.3 [1][1].<br/><br/>

This talk will give a brief introduction to the diagrams EDSL and how to use it, as well as an overview of some of the new features available in the 1.3 release. Some time will be spent on the finer details of making diagrams, and some cool pictures will be drawn.<br/><br/>

[1]: http://projects.haskell.org/diagrams/blog/2015-04-24-diagrams-1.3.html",
      "talk_date": "2015-05-27 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/222592682/",
      "youtubeId": "nZCzsBOYdis",
      "slides_url": "",
      "speaker": {
        "name": "Jeff Rosenbluth",
        "github": "",
        "twitter": ""
      },
      "modal": "diagrams20152"
    }, 
    {
      "title": "Diagrams: Composition, Envelopes, and Alignment Part 2",
      "abstract": "The diagrams library, which makes drawing complex pictures easy in with Haskell code, has just released a slew of new features with version 1.3 [1][1].<br/><br/>

This talk will give a brief introduction to the diagrams EDSL and how to use it, as well as an overview of some of the new features available in the 1.3 release. Some time will be spent on the finer details of making diagrams, and some cool pictures will be drawn.<br/><br/>

[1]: http://projects.haskell.org/diagrams/blog/2015-04-24-diagrams-1.3.html",
      "talk_date": "2015-05-27 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/222592682/",
      "img_thumb": "http://img.youtube.com/vi/5_fCUSOn7m0/hqdefault.jpg",
      "youtubeId": "5_fCUSOn7m0",
      "slides_url": "",
      "speaker": {
        "name": "Jeff Rosenbluth",
        "github": "",
        "twitter": ""
      },
      "modal": "diagrams20151"
    },  
    {
      "title": "Reflex: Practical FRP in Haskell (part 1)",
      "abstract": "Ryan Trinkle presents his new library, Reflex, a deterministic, efficient, higher-order Functional Reactive Programming system. FRP is a radically new paradigm for writing interactive software: Instead of writing event loops or callbacks, programmers compose interactive applications using ordinary pure functional programming methods. The unique design of Reflex gives it the power and flexibility necessary to handle complex large-scale applications. Reflex can be compiled to binary using GHC or JavaScript using GHCJS.",
      "bio": "Ryan Trinkle has been CTO of a successful Haskell-based startup, founder of an exclusively-Haskell software development company, and co-founder of the New York Haskell Meetup.",
      "talk_date": "2015-03-25 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/221142235/",
      "img_thumb": "http://img.youtube.com/vi/mYvkcskJbc4/hqdefault.jpg",
      "youtubeId": "mYvkcskJbc4",
      "slides_url": "",
      "speaker": [
        "name": "Ryan Trinkle",
        "github": "",
        "twitter": ""
      ],
      "modal": "reflexFRP1"
    },
    {
      "title": "Reflex: Practical FRP in Haskell (part 2)",
      "abstract": "Ryan Trinkle presents his new library, Reflex, a deterministic, efficient, higher-order Functional Reactive Programming system. FRP is a radically new paradigm for writing interactive software: Instead of writing event loops or callbacks, programmers compose interactive applications using ordinary pure functional programming methods. The unique design of Reflex gives it the power and flexibility necessary to handle complex large-scale applications. Reflex can be compiled to binary using GHC or JavaScript using GHCJS.",
      "bio": "Ryan Trinkle has been CTO of a successful Haskell-based startup, founder of an exclusively-Haskell software development company, and co-founder of the New York Haskell Meetup.",
      "talk_date": "2015-03-25 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/221142235/",
      "img_thumb": "http://img.youtube.com/vi/3qfc9XFVo2c/hqdefault.jpg",
      "youtubeId": "3qfc9XFVo2c",
      "slides_url": "https://obsidian.systems/reflex-nyhug/",
      "speaker": {
        "name": "Ryan Trinkle",
        "github": "",
        "twitter": ""
      },
      "modal": "reflexFRP2"
    },
    {
      "title": "Generating a Javascript SDK",
      "abstract": "",
      "talk_date": "",
      "meetup_url": "",
      "img_thumb": "http://img.youtube.com/vi/fTNEDhMjevQ/hqdefault.jpg",
      "youtubeId": "fTNEDhMjevQ",
      "slides_url": "",
      "reddit_url": "http://www.reddit.com/r/haskell/comments/2y4tof/dancing_with_the_devil_generating_a_javascript_sdk/",
      "speaker": {
        "name": "Evan",
        "github": "",
        "twitter": ""
      },
      "modal": "jsSDK"
    },
    {
      "title": "Vivid: Sound Synthesis in Haskell",
      "abstract": "In this talk, I'll give you a tour of Vivid, a new Haskell sound synthesis library, which acts as a frontend to the SuperCollider synthesis engine.  You'll see how to create sounds and music with it, how it's built, and possibilities for future directions.",
      "bio": "Tom Murphy is a Haskell programmer at skedge.me in New York.  He's interested in typed functional programming, digital art, and correctness in large software systems.  Previously, he's worked with Erlang and Rails, among others.",
      "talk_date": "",
      "meetup_url": "",
      "img_thumb": "http://img.youtube.com/vi/xo3zUvPsizo/hqdefault.jpg",
      "youtubeId": "xo3zUvPsizo",
      "slides_url": "",
      "reddit_url": "http://www.reddit.com/r/haskell/comments/2ycm0s/vivid_sound_synthesis_in_haskell_nyhaskell_meetup/",
      "speaker": {
        "name": "Tom Murphy",
        "github": "",
        "twitter": ""
      },
      "modal": "soundSynth"
    },
    {
      "title": "Introduction to Type Inference",
      "abstract": "Have you ever wondered what a \"rigid type variable\" was, and why Haskell was complaining about trying to unify it?  An intuition of how Haskell's type system works is an absolute must for Haskell programmers (as well as Ocaml programmers, Scala programmers, Swift programmers, etc.).  The easiest way to gain that intuition is to see an actual, if simplified, type system developed. Brian starts with a simplified subset of Haskell and develops a simplified type system for it- but not so simplified that critical problems aren't addressed.",
      "talk_date": "2015-04-22 20:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/221660808/",
      "img_thumb": "http://img.youtube.com/vi/il3gD7XMdmA/hqdefault.jpg",
      "youtubeId": "il3gD7XMdmA",
      "slides_url": "https://github.com/bhurt/presentations/raw/master/types.pdf",
      "speaker": {
        "name": "Brian Hurt",
        "github": "",
        "twitter": ""
      },
      "modal": "typeInference"
    },
    {
      "title": "How to define Data Types",
      "abstract": "It's one thing to know about the numerous features for defining datatypes in Haskell; it's another to know when to use each one, to maximize the utility of your datatype definitions and minimize boilerplate code for working with them.  In this talk, we will define a set of \"rules of thumb\" for writing datatype definitions; these rules, inspired by Edward Kmett's practices and 100% lens-friendly, will scale with you as you grow from beginner to experienced Haskell programmer.",
      "talk_date": "2015-04-22 19:00:00",
      "meetup_url": "http://www.meetup.com/NY-Haskell/events/221660808/",
      "img_thumb": "http://img.youtube.com/vi/zV70nrsMEZg/hqdefault.jpg",
      "youtubeId": "zV70nrsMEZg",
      "slides_url": "http://nocandysw.com/how-to-define-data-types.pdf",
      "speaker": {
        "name": "Stephen Compall",
        "github": "",
        "twitter": ""
      },
      "modal": "defineTypes"
    }
  ]
}


